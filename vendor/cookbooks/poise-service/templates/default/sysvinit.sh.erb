#!/bin/sh
# Init script for <%= @name %> generated by poise-service
#
### BEGIN INIT INFO
# Provides: <%= @name %>
# Required-Start: $remote_fs $syslog
# Required-Stop: $remote_fs $syslog
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: Init script for <%= @name %>
# Description: Init script for <%= @name %>
### END INIT INFO

<%- if @platform_family == 'debian' -%>
. /lib/lsb/init-functions

_start() {
  start-stop-daemon --start --quiet --background \
      --pidfile "<%= @pid_file %>"<% unless @pid_file_external %> --make-pidfile<% end %> \
      --chuid "<%= @user %>" --chdir "<%= @directory %>" \
      --exec "<%= @daemon %>" -- <%= @daemon_options %>
}

_stop() {
  start-stop-daemon --stop --quiet --pidfile "<%= @pid_file %>" --user "<%= @user %>" --signal "<%= @stop_signal %>"
}

_status() {
  status_of_proc -p "<%= @pid_file %>" "<%= @daemon %>" "<%= @name %>"
}

_reload() {
  start-stop-daemon --stop --quiet --pidfile "<%= @pid_file %>" --user "<%= @user %>" --signal "<%= @reload_signal %>"
}

<%- else -%>
_start() {
  <%# Implementing this using RedHat's bash helpers is too painful. Sorry. %>
  <%# See dummy.rb for a more commented version of this code. %>
  /opt/chef/embedded/bin/ruby <<EOH
require 'etc'
pid_file = <%= @pid_file.inspect %>
File.unlink(pid_file) if File.exist?(pid_file)
if Process.fork
  sleep(1) until File.exist?(pid_file)
else
  Process.daemon(true)
  Dir.chdir(<%= @directory.inspect %>)
  <%- unless @pid_file_external -%>
  IO.write(pid_file, Process.pid)
  <%- end -%>
  ent = Etc.getpwnam(<%= @user.inspect %>)
  if Process.euid != ent.uid || Process.egid != ent.gid
    Process.initgroups(ent.name, ent.gid)
    Process::GID.change_privilege(ent.gid) if Process.egid != ent.gid
    Process::UID.change_privilege(ent.uid) if Process.euid != ent.uid
  end
  Kernel.exec(*<%= Shellwords.split(@command).inspect %>)
  exit!
end
EOH
}

_stop() {
  if [ -r "<%= @pid_file %>" ]; then
    kill -<%= @stop_signal%> "$(cat "<%= @pid_file %>")"
  else
    return 0
  fi
}

_status() {
  if [ -r "<%= @pid_file %>" ]; then
    kill -0 "$(cat "<%= @pid_file %>")"
  else
    return 1
  fi
}

_reload() {
  if [ -r "<%= @pid_file %>" ]; then
    kill -<%= @reload_signal%> "$(cat "<%= @pid_file %>")"
  else
    return 1
  fi
}

<%# Some functions to match LSB %>

log_daemon_msg() {
  echo -n "$1"
}

log_progress_msg() {
  echo -n "$1"
}

log_warning_msg() {
  echo -n "$1"
}

log_failure_msg() {
  echo -n "$1"
}

log_end_msg() {
  if [ "$1" = 0 ]; then
    echo " [  OK  ]"
  else
    echo " [FAILED]"
  fi
}
<%- end -%>

set -e

start() {
  if _start
  then
    rc=0
    sleep 1
    if ! kill -0 "$(cat "<%= @pid_file %>")" >/dev/null 2>&1; then
        log_failure_msg "<%= @name %> failed to start"
        rc=1
    fi
  else
    rc=1
  fi
  if [ "$rc" -eq 0 ]; then
    log_end_msg 0
  else
    log_end_msg 1
    rm -f "<%= @pid_file %>"
  fi
}

<%- @environment.each do |key, val| -%>
export <%= key %>="<%= val %>"
<%- end -%>
export PATH="${PATH:+$PATH:}/usr/sbin:/sbin"

case "$1" in
  start)
    log_daemon_msg "Starting <%= @name %>"
    if [ -s "<%= @pid_file %>" ] && kill -0 "$(cat "<%= @pid_file %>")" >/dev/null 2>&1; then
      log_progress_msg "apparently already running"
      log_end_msg 0
      exit 0
    fi
    start
  ;;

  stop)
    log_daemon_msg "Stopping <%= @name %>"
    _stop
    log_end_msg "$?"
    rm -f "<%= @pid_file %>"
  ;;

  reload|force-reload)
    log_daemon_msg "Reloading <%= @name %>"
    _reload
    log_end_msg "$?"
  ;;

  restart)
    set +e
    log_daemon_msg "Restarting <%= @name %>"
    if [ -s "<%= @pid_file %>" ] && kill -0 "$(cat "<%= @pid_file %>")" >/dev/null 2>&1; then
      _stop || true
      sleep 1
    else
      log_warning_msg "<%= @name %> not running, attempting to start."
      rm -f "<%= @pid_file %>"
    fi
    start
  ;;

  status)
    set +e
    _status
    exit $?
  ;;

  *)
    echo "Usage: /etc/init.d/<%= @name %> {start|stop|reload|force-reload|restart|status}"
    exit 1
esac

exit 0
